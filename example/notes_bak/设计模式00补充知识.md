# 前言

<span style="color:red;font-weight:bold;font-size:17px;background:yellow">代码实现移步Github仓库(为了笔记的简洁)</span>

# 设计模式的概念

> **软件设计模式是一套被反复使用、多数人知晓的、经过分类编目的、代码设计经验的总结。它描述了在软件设计过程中的一些不断重复发生的问题，以及该问题的解决方案。**
> **它是解决特定问题的一系列套路，是前辈们的代码设计经验的总结，具有一定的普遍性，可以反复使用。**

# 设计模式的本质

> **设计模式的本质是<mark>面向对象设计原则的实际运用</mark>，是对类的封装性、继承性和多态性以及类的关联关系和组合关系的充分理解。**

# 设计模式优点

- 可以提高程序员的思维能力、编程能力和设计能力。
- 使程序设计更加标准化、代码编制更加工程化，使软件开发效率大大提高，从而缩短软件的开发周期。
- 使设计的代码可重用性高、可读性强、可靠性高、灵活性好、可维护性强。

# 设计模式分类

1. 创建型模式(**用于描述“怎样创建对象”，它的主要特点是“将对象的创建与使用分离”**)
   - 单例模型
   - 原型模型
   - 工厂方法
   - 抽象工厂
   - 建造者
2. 结构型模式(**用于描述如何将类或对象按某种布局组成更大的结构**)
   - 代理模式
   - 适配器模式
   - 桥接模式
   - 装饰模式
   - 外观模式
   - 享元模式
   - 组合模式
3. 行为型模式(**用于描述类或对象之间怎样相互协作共同完成工作，以及怎样分配职责**)
   - 模板方法
   - 策略模式
   - 命令模式
   - 职责链
   - 状态模式
   - 观察者模式
   - 中介者模式
   - 迭代器
   - 访问者模式
   - 备忘录
   - 解释器

# UML图

> UML即 统一建模语言,是用来设计软件的可视化建模语言。它的特点是简单、统一、图形化、能表达软件设计中的动态与静态信息。

- 用例图
- 类图
- 对象图
- 状态图
- 活动图
- 时序图
- 协作图
- 构件图
- 部署图

## 类图表示法

​							![image-20211025081603117](Z:\MyNotes\github图床\cloud_img\data\image-20211025081603117.png)
属性/方法名称前加的 + 和 - 表示了这个属性/方法的可见性，UML类图中表示可见性的符号有三种：

* **+：表示public**

* **-：表示private**

* **#：表示protected**

属性的完整表示方式是： **可见性  名称 ：类型 [ = 缺省值]  `+ name : String = null`**

方法的完整表示方式是： **可见性  名称(参数列表) [ ： 返回类型]** 

> **警示:**
>
> 1. **`[ ]`表示可选内容**
> 2. **建议使用上述的标准写法**

### 类图示例

​						  ![image-20211025082118879](Z:\MyNotes\github图床\cloud_img\data\image-20211025082118879.png)

Demo类定义了三个方法:

- method()方法：修饰符为public，没有参数，没有返回值
- method1()方法：修饰符为private，没有参数，返回值类型为String
- method2()方法：修饰符为protected，接收两个参数，第一个参数类型为int，第二个参数类型为String，返回值类型是int

# 类间关系的表示

## 一般关联关系

> 关联关系是**对象之间的一种引用关系**，用于表示一类对象与另一类对象之间的联系
> 如：老师和学生、师傅和徒弟、丈夫和妻子等
>
> 关联关系是类与类之间最常用的一种关系，分为**一般关联关系、聚合关系和组合关系**。我们先介绍一般关联。
>
> 一般关联又可以分为单向关联，双向关联，自关联。

### 单向关联

> 【关联关系】：是一种拥有的关系, 它使一个类知道另一个类的属性和方法；如：老师与学生，丈夫与妻子
>
> 关联可以是双向的，也可以是单向的。双向的关联可以有两个箭头或者没有箭头，单向的关联有一个箭头。
>
> **【代码体现】：成员变量**
>
> 【箭头及指向】：带普通箭头（或实心三角形箭头）的实心线，指向被拥有者		  

![image-20211025082528596](Z:\MyNotes\github图床\cloud_img\data\image-20211025082528596.png)
在UML类图中单向关联用一个带箭头的实线表示。上图表示每个顾客都有一个地址，这通过让Customer类持有一个类型为Address的成员变量类实现

### 双向关联

 ![image-20211025082719554](Z:\MyNotes\github图床\cloud_img\data\image-20211025082719554.png)
从上图中我们很容易看出，所谓的双向关联就是双方各自持有对方类型的成员变量。

在UML类图中，双向关联用一个不带箭头的直线表示。上图中在Customer类中维护一个List\<Product>，表示一个顾客可以购买多个商品；在Product类中维护一个Customer类型的成员变量表示这个产品被哪个顾客所购买。

### 自关联

​						![image-20211025082838131](Z:\MyNotes\github图床\cloud_img\data\image-20211025082838131.png)
自关联在UML类图中用一个带有箭头且指向自身的线表示。上图的意思就是Node类包含类型为Node的成员变量，也就是“自己包含自己”。比如LinkedList

## 聚合关系

> 关联和聚合在语法上无法区分，必须考察具体的逻辑关系。
>
> **【代码体现】：成员变量**
>
> 【箭头及指向】：带空心菱形的实心线，**菱形指向整体**

> 聚合关系是关联关系的一种，**是强关联关系，是整体和部分之间的关系**
>
> **==聚合关系也是通过成员对象==**来实现的，其中成员对象是整体对象的一部分，但是成员对象可以脱离整体对象而独立存在。例如，学校与老师的关系，学校包含老师，但如果学校停办了，老师依然存在。

​         <img src="Z:\MyNotes\github图床\cloud_img\data\image-20211025083832808.png" alt="image-20211025083832808" style="zoom:80%;" />
在 UML 类图中，聚合关系可以用带空心菱形的实线来表示，菱形指向整体

## 组合关系

> **【代码体现】：成员变量**
>
> 【箭头及指向】：带实心菱形的实线，**菱形指向整体**

> 组合表示类之间的整体与部分的关系，但它**是一种更强烈的聚合关系**
>
> 在组合关系中，==整体对象可以控制部分对象的生命周期==，一旦整体对象不存在，部分对象也将不存在，部分对象不能脱离整体对象而存在。
> 例如，头和嘴的关系，没有了头，嘴也就不存在了

​          <img src="Z:\MyNotes\github图床\cloud_img\data\image-20211025084038078.png" alt="image-20211025084038078" style="zoom:80%;" />
在 UML 类图中，组合关系用带实心菱形的实线来表示，菱形指向整体

## 依赖关系

> 【依赖关系】：是一种使用的关系, 即一个类的实现需要另一个类的协助, 所以要尽量不使用双向的互相依赖.
>
> **【代码表现】：局部变量、方法的参数或者对静态方法的调用**
>
> 【箭头及指向】：带箭头的虚线，**指向被使用者**

> 依赖关系是一种使用关系，它**是对象之间耦合度最弱的一种关联方式**，是**临时性的关联**。
>
> 在代码中，**某个类的方法通过==局部变量、方法的参数或者对静态方法的调用==来访问另一个类（被依赖类）中的某些方法来完成一些职责**

​          	<img src="Z:\MyNotes\github图床\cloud_img\data\image-20211025084448474.png" alt="image-20211025084448474" style="zoom:80%;" />
在 UML 类图中，依赖关系使用带箭头的虚线来表示，箭头从使用类指向被依赖的类

## 继承关系

> 继承关系**是对象之间耦合度最大的一种关系**，表示一般与特殊的关系，是父类与子类之间的关系

<img src="Z:\MyNotes\github图床\cloud_img\data\image-20211025084640871.png" alt="image-20211025084640871" style="zoom:80%;" />

在 UML 类图中，泛化关系用带空心三角箭头的实线来表示，箭头从子类指向父类。在代码实现时，使用面向对象的继承机制来实现泛化关系

## 实现关系

> 实现关系是**接口与实现类之间的关系**。在这种关系中，类实现了接口，类中的操作实现了接口中所声明的所有的抽象操作

​		     <img src="Z:\MyNotes\github图床\cloud_img\data\image-20211025084852869.png" alt="image-20211025084852869" style="zoom:80%;" />

在 UML 类图中，实现关系使用带空心三角箭头的虚线来表示，箭头从实现类指向接口

## 关系强弱比较

**泛化** = **实现** > **组合** > **聚合** > **关联** > **依赖**

## ==关系综合图==

<img src="Z:\MyNotes\github图床\cloud_img\data\image-20211028105406993.png" alt="image-20211028105406993" style="zoom: 80%;" />

# 软件设计原则

## 开闭原则

> **==开放扩展，关闭修改==**
> 在程序需要进行拓展的时候，不能去修改原有的代码，实现一个热插拔的效果。简言之，是为了使程序的扩展性好，易于维护和升级。

**实现手段:**

- **接口(接口中的方法默认是public abstract)**
- **抽象类**

> 原因:
> 抽象灵活性好，适应性广，只要抽象的合理，可以基本保持软件架构的稳定。而软件中易变的细节可以从抽象派生来的实现类来进行扩展，当软件需要发生变化时，只需要根据需求重新派生一个实现类来扩展就可以了

### 示例

- 某输入法的皮肤设计模拟

分析:输入法皮肤是输入法背景图片、窗口颜色和声音等元素的组合。用户可以根据自己的喜爱更换自己的输入法的皮肤。这些皮肤有共同的特点，可以为其定义一个抽象类（AbstractSkin），而每个具体的皮肤（DefaultSpecificSkin和HeimaSpecificSkin）是其子类。用户窗体可以根据需要选择或者增加新的主题，而不需要修改原代码，所以它是满足开闭原则的。
        ![image-20211025085624928](Z:\MyNotes\github图床\cloud_img\data\image-20211025085624928.png) 

<span style="color:red;font-weight:bold;font-size:17px;background:yellow">代码实现移步Github仓库(为了笔记的简洁)</span>

## 里氏代换原则

> **==任何基(父)类可以出现的地方，子类一定可以出现==**
> 通俗理解：子类可以扩展父类的功能，但不能改变父类原有的功能
> 换句话说，子类继承父类时，除添加新的方法完成新增功能外，**==尽量不要重写父类的方法==**
>
> 如果通过重写父类的方法来完成新的功能，这样写起来虽然简单，但是整个继承体系的可复用性会比较差，特别是运用多态比较频繁时，程序运行出错的概率会非常大

### 典例

- 正方形不是长方形

  > 在数学领域里，正方形毫无疑问是长方形，它是一个长宽相等的长方形。所以，我们开发的一个与几何图形相关的软件系统，就可以顺理成章的让正方形继承自长方形(非常的合理dog)

​               <img src="Z:\MyNotes\github图床\cloud_img\data\image-20211025091027417.png" alt="image-20211025091027417" style="zoom:80%;" />

我们运行一下这段代码就会发现:

> 1. 假如我们把一个普通长方形作为参数传入resize方法，就会看到长方形宽度逐渐增长的效果，当宽度大于长度,代码就会停止，这种行为的结果符合我们的预期
> 2. 假如我们再把一个正方形作为参数传入resize方法后，就会看到正方形的宽度和长度都在不断增长，代码会一直运行下去，直至系统产生溢出错误

所以，普通的长方形是适合这段代码的，正方形不适合(即父类可出现之地,子类不可出现)
由此，我们得出结论：在resize方法中，Rectangle类型的参数是不能被Square类型的参数所代替，如果进行了替换就得不到预期结果。因此，**Square类和Rectangle类之间的继承关系违反了里氏代换原则**，它们之间的继承关系不成立，正方形不是长方形

如何改进呢？此时我们需要重新设计他们之间的关系。抽象出来一个四边形接口(Quadrilateral)，让Rectangle类和Square类实现Quadrilateral接口 
            <img src="Z:\MyNotes\github图床\cloud_img\data\image-20211025093054158.png" alt="image-20211025093054158" style="zoom:80%;" />

## 依赖倒转原则

> 高层模块不应该依赖低层模块，两者都应该依赖其抽象；抽象不应该依赖细节，细节应该依赖抽象
> 简单的说就是**==要求对抽象进行编程==**，不要对实现进行编程，这样就降低了客户与实现模块间的耦合
>
> 比如:![image-20211025175211847](Z:\MyNotes\github图床\cloud_img\data\image-20211025175211847.png)

### 示例

- 组装电脑

  > 现要组装一台电脑，需要配件cpu，硬盘，内存条。只有这些配置都有了，计算机才能正常的运行。选择cpu有很多选择，如Intel，AMD等，硬盘可以选择希捷，西数等，内存条可以选择金士顿，海盗船等

不采用依赖倒转原则时,类图如下:<img src="Z:\MyNotes\github图床\cloud_img\data\image-20211025175211849.png" style="zoom:80%;" />

可以发现虽然已经组装了一台电脑，但是似乎组装的电脑的cpu只能是Intel的(比如笔记本CPU)，内存条只能是金士顿的，硬盘只能是希捷的，这对用户肯定是不友好的，用户有了机箱肯定是想按照自己的喜好，选择自己喜欢的配件

**根据依赖倒转原则进行改进：**

代码我们只需要修改Computer类，让Computer类依赖抽象（各个配件的接口），而不是依赖于各个组件具体的实现类<img src="Z:\MyNotes\github图床\cloud_img\data\image-20211025175211851.png" style="zoom:80%;" />

面向对象的开发很好的解决了这个问题，一般情况下抽象的变化概率很小，让用户程序依赖于抽象，实现的细节也依赖于抽象。即使实现细节不断变动，只要抽象不变，客户程序就不需要变化。这大大降低了客户程序与实现细节的耦合度

## 接口隔离原则

> **客户端不应该被迫依赖于它不使用的方法；一个类对另一个类的依赖应该建立在最小的接口上**
>
> 比如:A类中有a、b两个方法,我只需要a方法,如果继承了A那么我将会额外得到b方法(于我而言无用),这就违背了接口隔离原则

### 示例

- 安全门案例

我们需要创建一个品牌的安全门，该安全门具有防火、防水、防盗的功能。可以将防火，防水，防盗功能提取成一个接口，形成一套规范。类图如下：  <img src="Z:\MyNotes\github图床\cloud_img\data\image-20211025210838252.png" alt="image-20211025210838252" style="zoom:80%;" />

上面的设计我们发现了它存在的问题，黑马品牌的安全门具有防盗，防水，防火的功能。现在如果我们还需要再创建一个传智品牌的安全门，而该安全门**只具有防盗、防水功能**呢？很显然如果实现SafetyDoor接口就违背了接口隔离原则，那么我们如何进行修改呢？看如下类图：![image-20211025210942477](Z:\MyNotes\github图床\cloud_img\data\image-20211025210942477.png)

## 迪米特法则

![image-20211026010419556](Z:\MyNotes\github图床\cloud_img\data\image-20211026010419556.png)

> **==迪米特法则又叫最少知识原则。只和你的直接”朋友“交谈，不跟“陌生人”说话==**
>
> 就是说：一个类对自己依赖的类知道的越少越好。也就是说**==无论被依赖的类多么复杂，都应该将逻辑封装在方法的内部，通过public方法提供给外部==**。这样当被依赖的类变化时，才能最小的影响该类。
> 
>最少知道原则的另一个表达方式是：只与直接的朋友通信。类之间只要有耦合关系，就叫朋友关系。耦合分为依赖、关联、聚合、组合等。我们称**出现为成员变量、方法参数、方法返回值中的类为直接朋友**。**局部变量、临时变量则不是直接的朋友**。我们**==要求陌生的类不要作为局部变量出现在类中==**。

### 示例

- 明星与经纪人的关系实例

  > 明星由于全身心投入艺术，所以许多日常事务由经纪人负责处理，如和粉丝的见面会，和媒体公司的业务洽淡等。
  >
  > 这里的经纪人是明星的朋友，而粉丝和媒体公司是陌生人，所以适合使用迪米特法则

类图如下：![](Z:\MyNotes\github图床\cloud_img\data\image-20211025210942499.png)

## 合成复用原则

> **尽量先使用组合或者聚合等关联关系来实现，其次才考虑使用继承关系来实现**
>
> 通常类的复用分为**继承复用**和**合成复用**两种

#### 继承复用缺点

- 继承复用破坏了类的封装性

  > 因为继承会将父类的实现细节暴露给子类，父类对子类是透明的，所以这种复用又称为“白箱”复用

- 子类与父类的耦合度高

  > 父类的实现的任何改变都会导致子类的实现发生变化，这不利于类的扩展与维护

- 它限制了复用的灵活性

  > 从父类继承而来的实现是静态的，在编译时已经定义，所以在运行时不可能发生变化

#### 组合/聚合复用优点

- 维持了类的封装性。

  > 因为成分对象的内部细节是新对象看不见的，所以这种复用又称为“黑箱”复用

- 对象间的耦合度低。可以在类的成员位置声明抽象

- 复用的灵活性高。

  > 这种复用可以在运行时动态进行，新对象可以动态地引用与成分对象类型相同的对象

### 示例

- 汽车分类管理程序

  > 汽车按“动力源”划分可分为汽油汽车、电动汽车等；按“颜色”划分可分为白色汽车、黑色汽车和红色汽车等。如果同时考虑这两种分类，其组合就很多。

类图如下： <img src="Z:\MyNotes\github图床\cloud_img\data\image-20211025212521453.png" alt="image-20211025212521453" style="zoom:67%;" />

从上面类图我们可以看到使用继承复用产生了很多子类，如果现在又有新的动力源或者新的颜色的话，就需要再定义新的类。我们**试着将继承复用改为聚合复用**看一下。<img src="Z:\MyNotes\github图床\cloud_img\data\image-20211025212609482.png" alt="image-20211025212609482" style="zoom:80%;" />

